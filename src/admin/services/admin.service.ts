import {
  BadRequestException,
  ConflictException,
  Injectable,
  Logger,
  NotFoundException,
  Inject,
  InternalServerErrorException,
} from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import type { Cache } from 'cache-manager';
import { TireNormalizer } from '../../catalog/domain/tire-normalizer';
import { PrismaService } from '../../prisma/prisma.service';

@Injectable()
export class AdminService {
  private readonly logger = new Logger(AdminService.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly tireNormalizer: TireNormalizer,
    @Inject(CACHE_MANAGER) private readonly cache: Cache,
  ) {}

  /**
   * Create a new tire mapping with auto-generated code
   * @param input - Object containing sizeRaw and optional variants
   * @returns Created mapping with auto-generated code
   * @throws BadRequestException if inputs are invalid
   * @throws ConflictException if size already exists (1:1 relationship)
   * @example
   * createMapping({ sizeRaw: '205/55R16', loadIndex: 91, speedIndex: 'V' })
   */
  async createMapping(input: {
    sizeRaw: string;
    loadIndex?: number;
    speedIndex?: string;
  }) {
    const { sizeRaw, loadIndex, speedIndex } = input;
    this.logger.debug(`Creating mapping: size=${sizeRaw}`);

    if (!sizeRaw?.trim()) {
      this.logger.warn(`Missing required field: sizeRaw`);
      throw new BadRequestException('"sizeRaw" is required');
    }

    const sizeData = this.tireNormalizer.parseSizeComponents(sizeRaw);

    const { tireCode, tireSize } = await this.prisma.$transaction(
      async (tx) => {
        // Check if size already exists (1:1 relationship)
        const existingSize = await tx.tireSize.findUnique({
          where: { sizeNormalized: sizeData.sizeNormalized },
          include: { tireCode: true },
        });

        if (existingSize && existingSize.tireCode) {
          this.logger.warn(
            `Tire size already mapped to code ${existingSize.tireCode.codePublic}: ${sizeData.sizeNormalized}`,
          );
          throw new ConflictException(
            `Tire size "${sizeData.sizeNormalized}" already has code "${existingSize.tireCode.codePublic}" (1:1 relationship)`,
          );
        }

        // Create or use existing TireSize (include tireCode for consistent typing)
        let tireSize = existingSize;
        if (!tireSize) {
          tireSize = await tx.tireSize.create({
            data: sizeData,
            include: { tireCode: true },
          });
        }

        if (!tireSize) {
          throw new InternalServerErrorException('Failed to create tire size');
        }

        // Create TireCode (code is auto-generated by DB sequence)
        const tireCode = await tx.tireCode.create({
          data: {
            tireSizeId: tireSize.id,
            // codePublic is auto-generated by DB sequence
          },
        });

        // Create variant if loadIndex and speedIndex provided
        if (loadIndex !== undefined && speedIndex) {
          await tx.tireVariant.create({
            data: {
              tireSizeId: tireSize.id,
              loadIndex,
              speedIndex,
            },
          });
          this.logger.log(
            `Variant created: ${loadIndex}${speedIndex} for size ${sizeData.sizeNormalized}`,
          );
        }

        return { tireCode, tireSize };
      },
    );

    this.logger.log(
      `Mapping created: id=${tireCode.id}, code=${tireCode.codePublic} (auto-generated)`,
    );

    await this.invalidateLookupCache(
      tireCode.codePublic,
      tireSize.sizeNormalized,
      tireSize.id,
    );

    return {
      id: tireCode.id,
      codePublic: tireCode.codePublic,
      sizeRaw: tireSize.sizeRaw,
      sizeNormalized: tireSize.sizeNormalized,
    };
  }

  /**
   * List all tire mappings with their sizes and optional variants
   */
  async listMappings() {
    const mappings = await this.prisma.tireCode.findMany({
      orderBy: { codePublic: 'asc' },
      include: {
        tireSize: {
          include: {
            tireVariants: true,
          },
        },
      },
    });

    return mappings.map((mapping) => ({
      id: mapping.id,
      codePublic: mapping.codePublic,
      sizeRaw: mapping.tireSize.sizeRaw,
      sizeNormalized: mapping.tireSize.sizeNormalized,
      variants: mapping.tireSize.tireVariants.map((variant) => ({
        loadIndex: variant.loadIndex ?? undefined,
        speedIndex: variant.speedIndex ?? undefined,
      })),
    }));
  }

  /**
   * Update an existing tire mapping
   * NOTE: codePublic is immutable and auto-generated, cannot be updated
   * @param id - Mapping ID to update
   * @param input - Object containing optional sizeRaw and/or variant data
   * @returns Updated mapping with normalized data
   * @throws NotFoundException if mapping not found
   * @throws BadRequestException if no fields provided
   * @throws ConflictException if size already exists
   * @example
   * updateMapping('uuid', { sizeRaw: '225/50R17', loadIndex: 91, speedIndex: 'V' })
   */
  async updateMapping(
    id: string,
    input: {
      sizeRaw?: string;
      loadIndex?: number;
      speedIndex?: string;
    },
  ) {
    this.logger.debug(
      `Updating mapping: id=${id}, input=${JSON.stringify(input)}`,
    );

    if (
      !input.sizeRaw?.trim() &&
      input.loadIndex === undefined &&
      !input.speedIndex
    ) {
      this.logger.warn(`No fields provided to update mapping: ${id}`);
      throw new BadRequestException(
        'Provide "sizeRaw", "loadIndex", or "speedIndex" to update',
      );
    }

    const { existing, updatedSize, previousSizeNormalized } =
      await this.prisma.$transaction(async (tx) => {
        const existing = await tx.tireCode.findUnique({
          where: { id },
          include: { tireSize: true },
        });

        if (!existing) {
          this.logger.warn(`Mapping not found for update: ${id}`);
          throw new NotFoundException(`Mapping "${id}" not found`);
        }

        let updatedSize = existing.tireSize;
        const previousSizeNormalized = existing.tireSize.sizeNormalized;

        if (input.sizeRaw?.trim()) {
          const sizeData = this.tireNormalizer.parseSizeComponents(
            input.sizeRaw,
          );
          const sizeConflict = await tx.tireSize.findUnique({
            where: { sizeNormalized: sizeData.sizeNormalized },
          });

          if (sizeConflict && sizeConflict.id !== existing.tireSizeId) {
            this.logger.warn(
              `Size conflict during update: ${sizeData.sizeNormalized}`,
            );
            throw new ConflictException(
              `Tire size "${sizeData.sizeNormalized}" already exists`,
            );
          }

          this.logger.log(
            `Size updated: id=${id}, newSize=${sizeData.sizeNormalized}`,
          );
          updatedSize = await tx.tireSize.update({
            where: { id: existing.tireSizeId },
            data: sizeData,
          });
        }

        // Update or create variant if provided
        if (input.loadIndex !== undefined && input.speedIndex) {
          await tx.tireVariant.upsert({
            where: {
              tireSizeId_loadIndex_speedIndex: {
                tireSizeId: existing.tireSizeId,
                loadIndex: input.loadIndex,
                speedIndex: input.speedIndex,
              },
            },
            create: {
              tireSizeId: existing.tireSizeId,
              loadIndex: input.loadIndex,
              speedIndex: input.speedIndex,
            },
            update: {},
          });
          this.logger.log(
            `Variant updated/created: ${input.loadIndex}${input.speedIndex}`,
          );
        }

        return { existing, updatedSize, previousSizeNormalized };
      });

    await this.invalidateLookupCache(
      existing.codePublic,
      previousSizeNormalized,
      existing.tireSizeId,
    );
    await this.invalidateLookupCache(
      existing.codePublic,
      updatedSize.sizeNormalized,
      updatedSize.id,
    );

    return {
      id: existing.id,
      codePublic: existing.codePublic,
      sizeRaw: updatedSize.sizeRaw,
      sizeNormalized: updatedSize.sizeNormalized,
    };
  }

  /**
   * Delete a tire mapping by ID
   * @param id - Mapping ID to delete
   * @returns Deleted mapping data
   * @throws NotFoundException if mapping not found
   * @example
   * deleteMapping('uuid')
   */
  async deleteMapping(id: string) {
    this.logger.debug(`Deleting mapping: ${id}`);
    const existing = await this.prisma.tireCode.findUnique({
      where: { id },
      include: { tireSize: true },
    });

    if (!existing) {
      this.logger.warn(`Mapping not found for delete: ${id}`);
      throw new NotFoundException(`Mapping "${id}" not found`);
    }

    await this.prisma.tireSize.delete({
      where: { id: existing.tireSizeId },
    });

    this.logger.log(`Mapping deleted: id=${id}, code=${existing.codePublic}`);

    await this.invalidateLookupCache(
      existing.codePublic,
      existing.tireSize.sizeNormalized,
      existing.tireSizeId,
    );

    return {
      id: existing.id,
      codePublic: existing.codePublic,
      sizeRaw: existing.tireSize.sizeRaw,
      sizeNormalized: existing.tireSize.sizeNormalized,
    };
  }

  private async invalidateLookupCache(
    codePublic: string,
    sizeNormalized: string,
    tireSizeId: string,
  ): Promise<void> {
    const variants = await this.prisma.tireVariant.findMany({
      where: { tireSizeId },
      select: { loadIndex: true, speedIndex: true },
    });

    const variantKeys = [this.buildVariantKey(null, null)];
    for (const variant of variants) {
      variantKeys.push(
        this.buildVariantKey(variant.loadIndex, variant.speedIndex),
      );
    }

    const keys = variantKeys.flatMap((variantKey) => [
      this.buildCodeCacheKey(codePublic, variantKey),
      this.buildSizeCacheKey(sizeNormalized, variantKey),
    ]);

    await Promise.all(keys.map((key) => this.cache.del(key)));
  }

  private buildVariantKey(
    loadIndex: number | null,
    speedIndex: string | null,
  ): string {
    if (loadIndex === null && speedIndex === null) {
      return 'base';
    }

    return `${loadIndex ?? ''}${speedIndex ?? ''}`;
  }

  private buildCodeCacheKey(codePublic: string, variantKey: string): string {
    return `lookup:code:${codePublic}:${variantKey}`;
  }

  private buildSizeCacheKey(
    sizeNormalized: string,
    variantKey: string,
  ): string {
    return `lookup:size:${sizeNormalized}:${variantKey}`;
  }
}
