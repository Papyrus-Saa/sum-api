import { Processor, WorkerHost, OnWorkerEvent } from '@nestjs/bullmq';
import { Logger, Inject } from '@nestjs/common';
import { Job } from 'bullmq';
import { PrismaService } from '../../prisma/prisma.service';
import { TireNormalizer } from '../../catalog/domain/tire-normalizer';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import type { Cache } from 'cache-manager';

interface CsvRow {
  size: string;
  loadIndex?: number;
  speedIndex?: string;
}

interface CsvImportJobData {
  rows: CsvRow[];
  userId?: string;
}

@Processor('csv-import')
export class CsvImportProcessor extends WorkerHost {
  private readonly logger = new Logger(CsvImportProcessor.name);

  constructor(
    private readonly prisma: PrismaService,
    private readonly tireNormalizer: TireNormalizer,
    @Inject(CACHE_MANAGER) private readonly cache: Cache,
  ) {
    super();
  }

  async process(
    job: Job<CsvImportJobData>,
  ): Promise<{ processed: number; errors: string[] }> {
    const attemptInfo =
      job.attemptsMade > 0 ? ` (attempt ${job.attemptsMade + 1})` : '';
    this.logger.log(
      `Processing CSV import job ${job.id}${attemptInfo} with ${job.data.rows.length} rows`,
    );

    const { rows } = job.data;
    const errors: string[] = [];
    let processed = 0;
    const maxRetries = 3;

    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      let rowSuccess = false;
      let lastError: Error | null = null;

      // Retry individual rows that fail (transient errors)
      for (let attempt = 0; attempt < maxRetries && !rowSuccess; attempt++) {
        try {
          if (attempt > 0) {
            this.logger.warn(
              `Retrying row ${i + 1}, attempt ${attempt + 1}/${maxRetries}`,
            );
            // Small delay before retry
            await new Promise((resolve) => setTimeout(resolve, 500 * attempt));
          }

          await job.updateProgress({ current: i + 1, total: rows.length });

          // Validate required fields
          if (!row.size) {
            errors.push(`Row ${i + 1}: Missing required field (size)`);
            rowSuccess = true; // Don't retry validation errors
            break;
          }

          const sizeData = this.tireNormalizer.parseSizeComponents(row.size);

          const result = await this.prisma.$transaction(async (tx) => {
            // Find or create the tire size
            let tireSize = await tx.tireSize.findUnique({
              where: { sizeNormalized: sizeData.sizeNormalized },
              include: { tireCode: true },
            });

            if (!tireSize) {
              tireSize = await tx.tireSize.create({
                data: sizeData,
                include: { tireCode: true },
              });
            }

            // Enforce 1:1: size can only have one code
            if (tireSize.tireCode) {
              throw new Error(
                `Row ${i + 1}: Size ${sizeData.sizeNormalized} already has auto-generated code ${tireSize.tireCode.codePublic}. Delete the existing mapping first if you want to reimport.`,
              );
            }

            // Create code (auto-generated by DB sequence)
            const newCode = await tx.tireCode.create({
              data: {
                tireSizeId: tireSize.id,
                // codePublic is auto-generated by DB sequence
              },
            });

            // Create variant if indices provided
            if (row.loadIndex !== undefined && row.speedIndex) {
              await tx.tireVariant.create({
                data: {
                  tireSizeId: tireSize.id,
                  loadIndex: row.loadIndex,
                  speedIndex: row.speedIndex,
                },
              });
            }

            return {
              codePublic: newCode.codePublic,
              sizeNormalized: tireSize.sizeNormalized,
            };
          });

          // Invalidate cache for auto-generated code and size
          const cacheKeys = [
            this.buildCodeCacheKey(result.codePublic, 'base'),
            this.buildSizeCacheKey(result.sizeNormalized, 'base'),
          ];

          if (row.loadIndex !== undefined && row.speedIndex) {
            const variantKey = this.buildVariantKey(
              row.loadIndex,
              row.speedIndex,
            );
            cacheKeys.push(
              this.buildCodeCacheKey(result.codePublic, variantKey),
              this.buildSizeCacheKey(result.sizeNormalized, variantKey),
            );
          }

          for (const key of cacheKeys) {
            await this.cache.del(key);
          }

          processed++;
          rowSuccess = true; // Row processed successfully, exit retry loop
        } catch (error) {
          lastError =
            error instanceof Error ? error : new Error('Unknown error');
          const isRetryable = this.isRetryableError(lastError);

          if (!isRetryable) {
            // Don't retry business logic errors (validation, duplicates, etc.)
            this.logger.error(
              `Non-retryable error on row ${i + 1}:`,
              lastError,
            );
            errors.push(`Row ${i + 1}: ${lastError.message}`);
            rowSuccess = true; // Mark as handled, don't retry
            break;
          }

          // Transient errors (DB connection, timeout) will be retried
          this.logger.warn(
            `Retryable error on row ${i + 1}, attempt ${attempt + 1}/${maxRetries}:`,
            lastError.message,
          );
        }
      }

      // If all retries exhausted, log final error
      if (!rowSuccess && lastError) {
        this.logger.error(
          `Failed to process row ${i + 1} after ${maxRetries} attempts:`,
          lastError,
        );
        errors.push(
          `Row ${i + 1}: ${lastError.message} (failed after ${maxRetries} retries)`,
        );
      }
    }

    this.logger.log(
      `Completed job ${job.id}: ${processed}/${rows.length} rows processed`,
    );
    return { processed, errors };
  }

  /**
   * Determine if an error is retryable (transient) or permanent
   * @private
   */
  private isRetryableError(error: Error): boolean {
    const message = error.message.toLowerCase();

    // Non-retryable errors (business logic, validation)
    if (
      message.includes('already has auto-generated code') ||
      message.includes('invalid tire size') ||
      message.includes('missing required field') ||
      message.includes('badrequest')
    ) {
      return false;
    }

    // Retryable errors (transient issues)
    if (
      message.includes('connection') ||
      message.includes('timeout') ||
      message.includes('econnrefused') ||
      message.includes('enotfound') ||
      message.includes('deadlock')
    ) {
      return true;
    }

    // Default: assume transient for safety
    return true;
  }

  @OnWorkerEvent('active')
  onActive(job: Job) {
    this.logger.log(`Job ${job.id} is now active`);
  }

  @OnWorkerEvent('completed')
  onCompleted(job: Job) {
    this.logger.log(`Job ${job.id} completed successfully`);
  }

  @OnWorkerEvent('failed')
  onFailed(job: Job, error: Error) {
    this.logger.error(`Job ${job.id} failed:`, error);
  }

  private buildVariantKey(loadIndex?: number, speedIndex?: string): string {
    if (loadIndex === undefined && !speedIndex) {
      return 'base';
    }

    return `${loadIndex ?? ''}${speedIndex ?? ''}`;
  }

  private buildCodeCacheKey(codePublic: string, variantKey: string): string {
    return `lookup:code:${codePublic}:${variantKey}`;
  }

  private buildSizeCacheKey(
    sizeNormalized: string,
    variantKey: string,
  ): string {
    return `lookup:size:${sizeNormalized}:${variantKey}`;
  }
}
