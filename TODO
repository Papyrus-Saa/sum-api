PLAN MAESTRO “TIRECODE” — CHECKLIST POR ORDEN (de 0 a producción)

Aterrizaje del MVP (antes de escribir código)
<!-- [ ] Nombre del proyecto y repo definidos (ej. tirecode) listo -->
<!-- [ ] Regla 1:1 confirmada: medida base ↔ código público listo -->
<!-- [ ] Decisión de formato de medida base: “205/55R16” (sin espacios) listo -->
<!-- [ ] Decisión: LI/SI (carga/velocidad) opcional (ej. 91V) listo -->
<!-- [ ] Definir ejemplos reales (5–10) para tests y seed: listo -->
[ ] “205/55R16” → “100”
[ ] “195/65R15” → “101”
[ ] “215/60R16” → “102”
[ ] “225/45R17” → “103”
[ ] “235/50R18” → “104”
[ ] “245/40R18” → “105”
[ ] “255/55R19” → “106”
[ ] “265/70R17” → “107”
[ ] “205/55R16 91V” (variant) → “100 91V” (SI es una letra)
[ ] “225/45R17 94W” (variant) → “103 94W” (SI es una letra)
[ ] Contrato de búsqueda:
[ ] Input: “100” → salida: “205/55R16”
<!-- [ ] Contrato de búsqueda: listo -->
[ ] Input: “100” → salida: “205/55R16”
[ ] Input: “205/55R16” → salida: “100”
[ ] Input: “100 91V” o “205/55R16 91V” → salida: base + variant (si existe)
Setup profesional del repo (lo que te hace serio desde el día 1)
<!-- [ ] Crear repo Git + README (cómo correr dev en 5 líneas) listo -->
<!-- [ ] Inicializar backend NestJS (TypeScript strict) listo -->
<!-- [ ] ESLint + Prettier listo -->
<!-- [ ] Husky pre-commit: lint + test rápido (opcional, pero pro) listo -->
<!-- [ ] Config de env con validación (dev/stage/prod) listo -->
<!-- [ ] Dockerfile multi-stage para API listo -->
<!-- [ ] docker-compose dev: listo -->
<!-- [ ] api listo -->
<!-- [ ] postgres listo -->
<!-- [ ] redis listo -->
<!-- [ ] Scripts npm: listo -->
<!-- [ ] dev listo -->
<!-- [ ] lint listo -->
<!-- [ ] test listo -->
<!-- [ ] build listo -->
<!-- [ ] start:prod listo -->

Arquitectura y estructura (sin esto, en 1 mes es un spaghetti)
<!-- [ ] Crear módulos Nest (monolito modular): listo -->
<!-- [ ] catalog (core: medidas/códigos/variantes) listo -->
<!-- [ ] lookup (caso de uso de búsqueda) listo -->
<!-- [ ] admin (gestión) listo -->
<!-- [ ] observability (logging, health) listo -->
<!-- [ ] Definir capas (aunque sea simple): listo -->
<!-- [ ] controllers listo -->
<!-- [ ] services/use-cases listo -->
<!-- [ ] repositories (infra) listo -->
<!-- [ ] domain (reglas + normalización) listo -->
<!-- [ ] DTOs + validación en todos los endpoints listo -->
<!-- [ ] Error handling global (filter) con formato estándar: listo -->
[ ] { error: { code, message, details? }, requestId }

Base de datos (PostgreSQL) — modelo final sin huecos
El modelo queda así (para ser escalable y limpio):

[ ] Tabla tire_sizes
[ ] id (uuid)
[ ] size_raw (texto tal como lo envían)
[ ] size_normalized (UNIQUE) ej “205/55R16”
[ ] width (int) 205
[ ] aspect_ratio (int) 55
[ ] rim_diameter (int) 16
[ ] created_at / updated_at

[ ] Tabla tire_codes
[ ] id (uuid)
[ ] code_public (varchar) UNIQUE ← aquí guardas “100”
[ ] tire_size_id UNIQUE (FK) ← garantiza 1:1
[ ] created_at / updated_at

[ ] Tabla tire_variants (opcional)
[ ] id (uuid)
[ ] tire_size_id (FK)
[ ] load_index (int, nullable) ej 91
[ ] speed_index (varchar, nullable) ej “V”
[ ] UNIQUE(tire_size_id, load_index, speed_index)

[ ] Tabla search_logs (para futuro crecimiento)
[ ] id
[ ] query
[ ] query_type (code|size|unknown)
[ ] result_found (bool)
[ ] ip_hash
[ ] created_at

Índices/constraints imprescindibles:
<!-- [ ] UNIQUE(size_normalized) listo -->
<!-- [ ] UNIQUE(code_public) listo -->
<!-- [ ] UNIQUE(tire_size_id) en tire_codes listo -->
<!-- [ ] Índice en tire_variants por (tire_size_id, load_index, speed_index) listo -->
<!-- [ ] Migraciones (Prisma o TypeORM, pero con migrations sí o sí) listo -->
<!-- [ ] Seeds iniciales (50–200 filas) para pruebas listo -->

Normalizador (esto te hace “backend de nivel”)
[ ] Implementar normalización de medida:
[ ] quitar espacios
[ ] mayúsculas en “R”
[ ] aceptar entradas como “205/55 r16”, “205/55R 16”, “205 / 55 R16”
[ ] devolver siempre “205/55R16”
[ ] Parser opcional de LI/SI:
[ ] “91V” → load_index=91, speed_index=V
[ ] Tests unitarios del normalizador (varios casos raros)

API pública (primero lo que da valor)
[ ] GET /api/v1/lookup?code=100
[ ] si existe → { code: “100”, size: “205/55R16”, variant?: { li, si } }
[ ] si no → 404 consistente

[ ] GET /api/v1/lookup?size=205/55R16
[ ] devuelve { size, code }

[ ] Soporte opcional de LI/SI:
[ ] GET /api/v1/lookup?code=8&li=91&si=V
[ ] GET /api/v1/lookup?size=205/55R16&li=91&si=V
[ ] si la variant no existe → devuelve base y un aviso tipo “variant_not_found”

[ ] (Opcional UX) GET /api/v1/suggestions?query=205
[ ] devuelve top medidas/códigos por prefijo

[ ] Swagger completo desde el día 1 (con ejemplos)
[ ] Rate limiting en endpoints públicos (muy importante)
[ ] Logs con requestId

Frontend mínimo (para que el proyecto sea demostrable)
[ ] Next.js página única:
[ ] input único que acepta “100” o “205/55R16” o “205/55R16 91V”
[ ] detecta tipo (número vs medida)
[ ] llama /lookup
[ ] muestra resultado limpio + botón copiar
[ ] mensajes humanos (no “stack traces”)
[ ] Página “Qué es TireCode” (explicación corta)
[ ] SEO básico

Admin (manual primero, porque te acelera)
[ ] Crear admin auth (JWT)
[ ] Rol admin
[ ] Endpoints:
[ ] POST /api/v1/admin/mappings
[ ] PATCH /api/v1/admin/mappings/:id
[ ] DELETE /api/v1/admin/mappings/:id (soft delete opcional)
[ ] POST /api/v1/admin/variants (crear variant 91V para una medida)
[ ] Auditoría mínima (quién creó/editó)
[ ] Validaciones fuertes + errores consistentes

Redis cache (para ser rápido y escalable ya desde v1)
[ ] Cache lookup por code_public
[ ] Cache lookup por size_normalized
[ ] TTL (ej 1h) + invalidación exacta al cambiar mapping:
[ ] al editar mapping → borrar cache de ese code y size
[ ] Medir latencia con y sin cache (aunque sea simple)

Import CSV + BullMQ (para meter “todos los neumáticos”)
Primero: entender CSV:
– Es un archivo exportado de Excel con columnas.

[ ] Endpoint admin: POST /api/v1/admin/import (sube CSV)
[ ] Guardar archivo temporal o en storage
[ ] Encolar job BullMQ “importMappings”
[ ] Job:
[ ] parsea filas
[ ] normaliza size
[ ] upsert (crear si no existe, actualizar si existe)
[ ] idempotencia (mismo CSV no crea duplicados)
[ ] retries + backoff
[ ] Reporte del import:
[ ] cuántos OK
[ ] cuántos duplicados
[ ] cuántos fallos y por qué

Testing completo (lo que te hace “muy buscado”)
Unit tests:
[ ] normalizador de tamaño
[ ] parser de LI/SI
[ ] regla 1:1 (no duplicados)

Integration tests:
[ ] lookup por code (200/404)
[ ] lookup por size (200/404)
[ ] admin create mapping (unique)
[ ] import CSV (upsert correcto)
[ ] Testcontainers con Postgres real (si puedes, esto suma muchísimo)

Objetivo:
[ ] cobertura base 60–70% en módulos core

Observabilidad (producción real)
[ ] /health
[ ] logs estructurados (pino o winston)
[ ] métricas básicas (opcional /metrics)
[ ] trazabilidad: requestId en logs y respuestas
[ ] alertas mínimas (cuando esté en cloud)

CI/CD + despliegue (portfolio serio)
[ ] GitHub Actions:
[ ] lint
[ ] test
[ ] build
[ ] docker build
[ ] Deploy staging automático
[ ] Deploy producción con aprobación manual
[ ] Migraciones controladas en deploy
[ ] Secrets fuera del repo
[ ] Rollback plan (volver a imagen anterior)

Preparación para futuro (sin construir microservicios aún)
[ ] Documentar (1–2 páginas):
[ ] roles futuros: workshop/manufacturer
[ ] diseño de “tire_instances” (cuando haya QR por neumático individual)
[ ] estrategia de escalado:
– Monolito modular ahora
– Extraer search-service si tráfico explota
– Extraer import-service si import crece
[ ] Añadir search_logs + anti-abuso (rate limit más agresivo)
[ ] Suggestions mejoradas si hace falta (prefijo + ranking)

Entrega final (para ser “contratable fuerte”)
[ ] Repo público con README impecable
[ ] Demo en cloud funcionando
[ ] Dataset cargado (mínimo 200)
[ ] Diagrama simple (API + Postgres + Redis + BullMQ)
[ ] Video corto mostrando:
[ ] buscar por “100”
[ ] buscar por “205/55R16”
[ ] admin crea mapping
[ ] import CSV
